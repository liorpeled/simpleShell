)Process Creation: system initialization, execution of process creation using system call by running a process, user request to create new process and initiation of a batch job. If a single-threaded process is blocked on the keyboard, it cannot fork.Critical regions: memory areas sensitive to race conditions.Mutual Exclusion with Busy Waiting: attempt to solve CR issue, only work with single core processes, and only good for kernel.Lock variable solution alone still has race condition. strict alternation: could violates rule 3, and only works for 2 process. Peterson solution: uses lock and strict,but keeps track of interested processes. Scheduling Algorithm Goals: All System;Fairness - giving each process a fair share of the CPU,Policy Enforcement - seeing that stated policy is carried out, Balance - keeping all parts of system busy, Batch Systems:Throughput - maximize jobs per hour, Turnaround time - minimize time between submission and termination, CPU Utilization - keep the CPU busy all the time(First Come First Served, Shortest Job First,ShortestRemiaingtimefFirst, Priority-non preemptive). Interactive Systems: Response time - respond to requests quickly, Proportionality - meet users' expectations(Round Robin,priority(preemptive), Multilevel Feedback Queue,Lottery Scheduling). Real-time systems: Meeting deadlines - avoid losing data Predictability - avoid quality degradation in multimedia systems. Conditions for Resource Deadlocks: Mutual Exclusion:Each resource is either currently assigned to exactly one process or is available. Hold-and-Wait:Processes currently holding resources that were granted earlier can request new resources.No-preemption(recovery from Deadlock-preemption): Resources previously granted cannot be forcibly taken away from a process. They must be explicitly released by the process holding them.Circular wait condition:There must be a circular list of two or more processes, each of which is waiting for a resource held by the next member of the chain. A Memory Abstraction: Address Spaces - used to solve two issues - protection and relocation:. Managing Free Memory: Memory Management with Bitmaps: memory is divided to allocation units, each allocation is being mapped in a bitmap, a small bit can have more precision, but make the map larger, a larger unit, makes map smaller but can allocate extra memory for no reason. The issue with this, is that searching a map is a slow process. Mem management with linked list - free memory segments, each segment may have a process or is empty, each segment specifies a hole(H), or a process(P), an address where it starts, length and pointer to next segment. Page Replacement Algorithms: NRU algorithm: removes a page at random from the lowest-numbered nonempty class.It is better to remove a modified page that has not been referenced in at least one clock cycle, than a clean page in heavy use. Least Recently Used (LRU is stack algorithm) Replacement(hardware, NFU is software):  trivial, remove pages that has not been used for a while, and likely not be used in the near future. The Working Set Page Replacement Demand Paging - Pages are loaded on demand, as needed. As opposed to pre-loading in advance, Locality of reference - during any phase of execution, the process references only a relatively small fraction of its pages, Working set - set of pages that a process is currently using. 
File Systems:the file, a new abstraction to abstract your problems.File Structure:Three kinds of file structures: Byte Sequence(unstructured sequence of bytes. OS does not know or care what is in the file), Record Sequence(sequence of fixed-length records, each with some internal structure, one at time, read only one, write only one), Tree(consists of a tree of records, not necessarily all the same length, each containing a key field in a fixed position in the record).File Types:Directories, Character special(for I/O), block special(used to model disks), regular. One un-trivial file operation:Seek, move data pointer to any position in the file.For Directories untrivial is : Link: Allows a file to appear in more than one directory. File System Layout File systems are stored on disks, which can be divided up into one or more partitions Sector 0 - MBR (Master Boot Record), used to boot the computer.Contiguous Allocation:Store each file as a contiguous run of disk blocks - keep track of location is made easy, read performance is great, but over time disk becomes fragmented with memory holes.Linked-List Allocation-fix fragmentation, saves space, but bad random access. Linked -list allocation using a table in memory fixes both issues - drawback, is table must be in memory.Log-Structured File Systems: structure disk as one big log- When there is a special need for it, all the pending writes being buffered in memory are collected into a single segment and written to the disk as a single contiguous segment at the end of the log(good idea but not compatible with existing files). Journaling File Systems: When removing a file, requires 3 basic operation:Remove the file from its directory, Release the i-node to the pool of free i-nodes, Return all the disk blocks to the pool of free disk blocks.Managing free space: have a bit vector with one entry per file block, could have a linked list, which in structure is similar to file linked list I/O:Device Controllers: Often consist of mechanical and electronic component Electric is controller, mechanical is device itself. Controller can handle multiple devices of the same type, it convert bit stream to block of bytes, correct erros, make available to memory. Memory-Mapped I/O:Each controller has a few registers that are used for communicating with the CPU. OS can command the device to deliver data, accept data, switch itself on or off..problem is that it does not have special protection for memory, also single bus(compete) or dual bus(no compete, IO is slower) .Direct Memory Access - cpu programs DMA controller, DMA controller requests transfer to memory, data is transferred, ack, interrupt when done. IOGoals: device independence, uniform naming - independent from computer, error handling, blocked transfers vs interrupt driven (sync vs async transfers). Layers of IO: user(user software and lib), operating sys - kernel: device independent OS code, device drivers, interrupt handlers, hardware.Device drivers: between device controller and rest of os, communicate with controller over bus. Device -independent I/O software: uses common library routines for I/O software.disk sector: preamble(info about sector),data(512-1024 Bytes), ECC(error correcting code). Disk search algorithms: FCFS,shortest seek time first(for light load), SCAN(elevator, start at one end go to next),C-scan(same scan but goes back to beginning), C-LOOK(same as C-Scan but goes only as far as last request, in each direction, for heavy load). 
Security Environment: Goals - data confidentiality, data integrity, system availability. Protection: security is mostly about mechanism, is about specifying policies, specification must be correct. Protection domains: three protection domains, domains can share objects and permissions, each domain lists objects with permitted operations.Protection matrix( access matrix): row is domain, column is object, allows flexibility in specifying domain permissions. Matrix is mostly empty, compress by associating permissions with each object: access control list, associating permissions with each domain: capabilities. Access control lists: each object has a list, list has protection domain: user name or group of users(each is a domain, unix fs has three domains: user, group, others), access rights.AFS - access lists only apply to directories: files inherit rights from directories. Capabilities: each process has a capability list, each list has one entry per object the process can access, they are secure because they are in the kernel(cryptographically secure). All sys call go through reference monitor for security checking. Models of secure systems:Bell-La Padula model:processes, objects have level, process at level k can only read objects at k or lower, and write in  k or higher, prevents from higher levels to lower levels. Biba integrity model - opposite from Bell-La, it prevents someone from getting info from above and planting it at their level.. Cryptography - uses key, and algorithm to encrypt. Unbreakable codes - one time code. There are two keys, private and public who are reversed but not identical. One way function: given f(x), easy to evaluate y=h(x).pretty good privacy: use public key to exchange shared key (because public key is slow). One-time passwords- cannot be reused, implemented with one-way hash. Attacks on computer system: insider attacks: logic bombs: embeds logic “flaws” that trigger if conditions aren’t met, can be harmful. Trap doors: impeded code that provides a access to a user’s system. Login spoofing: identical login screen to original, but saves username and password. 
