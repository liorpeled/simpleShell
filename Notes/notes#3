Deadlock:
Two process that each has something that the other process needs but doesn’t give it up

Live lock - same as deadlock except they swap their possessions


Bounded buffer problem

Goal implement producer -consumer without busy waiting


Multiple writers and multiple readers 

Nerdy kids listen to their mother


Abording a  process can resolve a deadlock, or limiting how many processes can enter



Scheduling
Goals
Mechanisms
Scheduling on batch systems
Scheduling on interactive systems
Other kinds of scheduling
	Real time scheduling

Which process is being done first 

Temple.os

Why scheudle processes
Burst of CPU usage alternate with periods of I/O wait
Some processes are CPU-bound: they don’t many I/O requests
Other processes are I/O-bound and make many kernel requests 

CPU bound
	Computes stuff, add subtract multiply divide, move around stuff
I/o	waiting for input output  


Fortrun has no recursion  - no recursion do heapsort 


When are processes scheduled
At the time they enter the system
Common in batch systems
Two types of batch scheduling
Submission of a new job causes the scheduler to run
Scheduling only done when a job voluntarily gives up the cpu
At relatively fixed intervals
Necessary for interactive systems
May also be used for batch systems
Scheduling algorithms at teach interrupt, and picks the next process form the pool of “read” processes



All about throughput

Scheduling goals
All systems
Fairness: give each process a fair share of the CPU
Enforcement: ensure that the stated policy is carried out
Balance: keep all parts of the system busy
Batch systems
Throughput: maximize jobs per unit time (hour)
Turnaround time: minimize time users wait for jobs
CPU utilization: keep the CPU as busy as possible
Interactive systems
Response time: respond quickly to users’ requests
Proportionality: meet users’ expectations
Real-time systems
Meet deadlines: missing deadlines is a system failure!
Predictability: same type of behavior for each time slice


Interactive vs. batch scheduling
Batc
First come first served
Shortest job first
Shortest remaining time first
Priority(non-preemptive)


Interactive - processes share processor 
Round-robin
Priority (preemptive)
Multilevel feedback queue
Lottery scheduling 

Higher priority - more lottery tickets
Lower priority - less lottery tickets





Interactive vs batch scheduling

First come first served
Goal: do jobs in the order they arrive
Fair in the same way a bank teller line is fair
Simple algorithm

Problem: long jobs delay 



Shortest job first
Goal do the shortest job first
	Short jobs complete frist
Long jobs delay every job after

Jobs sorted in increasing order of execution time
	Ordering of ties doesn’t matter
Shortest remaining time first
	Preemptive form SJF
Re evaluate when a new job is submitted
Problem: how does the scheduler know how long a job will take


Starvation in shortest job 

In the old days, you had to specify memory and cpu power needed 

We try to set algorithms to be o(1), we will have suboptimal algorithms 


Jobs held in input queue until moved into memory
	Pick complementary jobs small and large, cpu  and I/O intensive
 Jobs move into memory when admitted
Cpu scheduler picks some jobs from main memory and moves them to disk if insufficient memory spaces


Process in memory does not mean necessarily it is in memory, it could be ready to be processed 
Psyc wars - gummy bear






Scheduling interactive processes
	Give each process a fixed time slot
	Rotate through “ready” processes
	Each process makes some progress

What’s a good quantum
	Too short: many process switches hurt efficiency
	Too long: poor response to interactive requests
	Typical length: 10 -100 ms
Stric rotation: round robin

Quantum is the time used to do a program - quantum - quantity - give limit

Priority scheduling
Assign a priority to each process
	REady process with highest priority allowed to run 
	Running process may be interrupted after its quantum
Expires

Priorities may be assigned dynamically
	Reduced when a process uses cpu time
	Increased when a process waits for I/O
Often, processes grouped into multiple queues based on priority, and run round robin per queue




Priorities may be assigned dynamically
	Reduced when a process uses cpu time

Can combine types of scheduling- 


Policy for doing something mechanism is an enforcement 





Shortest process next
	Run the process that will finish the soonest
		In interactive systems. Job completion time is unknown
	Guess at completion time based on previous runs
		Update estimate each time the job is run
		Estimate is a combination of previous estimate and most recent run time
	Not often used because round robin with priority works so well!!


Lottery scheduling
Give processes “tickets” for CPU time
More tickets -> higher share of CPU
Each quantum, pick a ticket at random
If there are n tickets, pick a number from 1 to n
Pseudo - random number is ok if its a good RNG
Process holding the ticket gets to run for a quantum
This can be implemented efficiently without “real” tickets
Track randge of tickets belongning to each process
Over the long run, each process gets the CPU m/n of the time if the process has m of the n existing tickets
Tickets can be transferred 
Cooperating processes can exchange tickets
Clients can transfer ticekts to a server so it can have a higher priority
Parent (shell) can transfer tickets to a child proceess

Ticket numbers - do not keep track if doing lottery scheduling  


Is scheduling order set in stone?

Why does ethernet work (old) - 





Scheduling in BSD4

Quantum is 100 ms: longest that’s ok for interactive scheuling
Scheduler is based on multi level feedback queues 
Priority is absed on two things
Resource requirements: blocked threads have higher priority when rescheduled
Priovs

Pri = MIN [estcpu/4] +2*nice


Values above MAX are set to MAX
Min = 160, MAX = 223
Nice is set by the user to manually lower thread priority
Estcpu is an estimate of the numberof “read” processes in the CPU when the calcualtion is made
Has a bit of “memory” so it doesn’t chagne too quickly 
Estcpu is updated each clock tick

Higher numbers incdicate lower priority: threads with lowest priority values are scheduled first
Thread priority is set every 40 ms
Scheduling is more complex for multiprocessors 

